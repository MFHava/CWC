//generated with CWCC

#pragma once
#include <cwc/cwc.hpp>

namespace cwc::sample::fibonacci {
	struct [[nodiscard]] sequence final {
		struct cwc_impl;

		sequence(const sequence &) =delete;
		sequence(sequence && cwc_other) noexcept : cwc_self{std::exchange(cwc_other.cwc_self, nullptr)} {}
		auto operator=(const sequence &) -> sequence & =delete;
		auto operator=(sequence && cwc_other) noexcept -> sequence & { std::swap(cwc_self, cwc_other.cwc_self); return *this; }
		~sequence() noexcept { cwc_dll().call<&cwc_vtable::cwc_0>(cwc_self); }


		sequence() { cwc_dll().call<&cwc_vtable::cwc_1>(&cwc_self); }

		[[deprecated("for visualization only")]]
		sequence(const int & dummy) =delete;

		//! @brief compute fibonacci number
		//! @returns fibonacci number
		[[nodiscard]]
		auto calculate(
			std::uint8_t no //!< [in] no
		) const -> std::uint64_t {
			std::uint64_t cwc_result;
			cwc_dll().call<&cwc_vtable::cwc_3>(cwc_self, std::move(no), std::addressof(cwc_result));
			return cwc_result;
		}

		void calculate() =delete;

		//! @returns max supported fibonacci number that can be computed before result would overflow
		[[nodiscard]]
		static
		auto max() noexcept -> std::uint8_t {
			std::uint8_t cwc_result;
			cwc_dll().call<&cwc_vtable::cwc_5>(std::addressof(cwc_result));
			return cwc_result;
		}
	private:
		friend
		cwc::internal::vtable_access<sequence>;

		struct cwc_vtable final {
			void(CWC_CALL * cwc_0)(cwc_impl *) noexcept;
			cwc::internal::error_callback(CWC_CALL * cwc_1)(cwc_impl **) noexcept;
			cwc::internal::error_callback(CWC_CALL * cwc_3)(const cwc_impl *, std::uint8_t, std::uint64_t *) noexcept;
			void(CWC_CALL * cwc_5)(std::uint8_t *) noexcept;
		};

		static
		auto cwc_dll() -> const cwc::internal::dll & {
			static const cwc::internal::dll instance{"sample-fibonacci", "cwc$sample$fibonacci$sequence"};
			return instance;
		}

		cwc_impl * cwc_self;
	};
#define CWC_EXPORT_cwc$sample$fibonacci$sequence \
	extern "C" CWC_EXPORT const typename cwc::internal::vtable_access<cwc::sample::fibonacci::sequence>::type cwc$sample$fibonacci$sequence{\
		+[](cwc::sample::fibonacci::sequence::cwc_impl * cwc_self) noexcept { delete cwc_self; },\
		+[](cwc::sample::fibonacci::sequence::cwc_impl ** cwc_result) noexcept { return cwc::internal::try_([&] { *cwc_result = new cwc::sample::fibonacci::sequence::cwc_impl{}; }); },\
		+[](const cwc::sample::fibonacci::sequence::cwc_impl * cwc_self, std::uint8_t no, std::uint64_t * cwc_result) noexcept { return cwc::internal::try_([&] { *cwc_result = (*cwc_self).calculate(std::move(no)); }); },\
		+[](std::uint8_t * cwc_result) noexcept { *cwc_result = cwc::sample::fibonacci::sequence::cwc_impl::max(); }\
	}
}
