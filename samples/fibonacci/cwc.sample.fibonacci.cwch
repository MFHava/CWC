//This file was generated for CWC by CWCC
//ATTENTION: Do not modify this file as its content is highly dependent on the design of CWC!
#pragma once
#include <cwc/cwc.hpp>

namespace cwc::sample::fibonacci {
	class sequence_ final {
		void * obj;
		void (*func)(void *, int, void **);

		static
		constexpr
		const char * dll{"sample-fibonacci"};
	public:
		sequence_(std::nullopt_t) noexcept : obj{nullptr}, func{nullptr} {} //TODO: need way to create internally without adding null-state (even possible?)

		template<typename Type>
		sequence_(std::in_place_type_t<Type>) { //TODO: general concept to construct with parameters
			static_assert(std::is_nothrow_destructible_v<Type>);

			obj = new Type{};
			func = [](void * ctx, int op, void ** args) {
				switch(op) {
					case 0: delete reinterpret_cast<Type *>(ctx); break;
					case 1: *reinterpret_cast<::cwc::uint64 *>(args[1]) = reinterpret_cast<const Type *>(ctx)->calculate(*reinterpret_cast<const ::cwc::uint8 *>(args[0])); break;
					//default: unreachable(); break;
				}
			};
		}

		sequence_(const sequence_ &) =delete;
		sequence_(sequence_ && other) noexcept {
			std::swap(obj, other.obj);
			std::swap(func, other.func);
		}
		auto operator=(const sequence_ &) -> sequence_ & =delete;
		auto operator=(sequence_ && other) noexcept -> sequence_ & {
			std::swap(obj, other.obj);
			std::swap(func, other.func);
			return *this;
		}

		~sequence_() noexcept { if(obj) func(obj, 0, nullptr); }

		auto calculate(const ::cwc::uint8 & no) const -> ::cwc::uint64 { //TODO: exception handling
			::cwc::uint64 result;
			void * args[]{(void *)&no, &result};
			func(obj, 1, args);
			return result;
		}
	};
}
