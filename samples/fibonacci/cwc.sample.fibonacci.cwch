//          Copyright Michael Florian Hava 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once
#include <cwc/cwc.hpp>

namespace cwc {
namespace sample {
//! @brief CWC Sample "Fibonacci Generator"
//! @author Michael Florian Hava
namespace fibonacci {
	class sequence : public ::cwc::component {
		virtual ::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$sequence$compute$0(::cwc::uint8 no, ::cwc::uint64 * cwc_ret) const noexcept =0;
	public:
		auto compute(const ::cwc::uint8 & no) const -> ::cwc::uint64 {
			::cwc::uint64 cwc_ret;
			::cwc::internal::call(*this, &sequence::cwc$sample$fibonacci$sequence$compute$0, no, &cwc_ret);
			return cwc_ret;
		}

		template<typename CWCImplementation, typename CWCTypeList>
		class cwc_implementation : public ::cwc::internal::default_implementation_chaining<CWCImplementation, CWCTypeList> {
			::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$sequence$compute$0(::cwc::uint8 no, ::cwc::uint64 * cwc_ret) const noexcept final {
				return ::cwc::internal::call_and_return_error([&] { *cwc_ret = static_cast<const CWCImplementation &>(*this).compute(no); });
			}
		};
		static auto cwc_uuid() -> ::cwc::uuid { return {0x55, 0x9, 0x67, 0x3D, 0x71, 0x7, 0x51, 0xC5, 0x97, 0xAA, 0x1F, 0xE8, 0xA8, 0x2A, 0x1A, 0x6}; }
	};

	struct generator : sequence {
		static void cwc_uuid() {}
		static auto cwc_fqn() -> ::cwc::string_view { return "cwc::sample::fibonacci::generator"; }
		using cwc_interfaces = ::cwc::internal::make_base_list<sequence>::type;

		class cwc_factory : public ::cwc::component {
			virtual ::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$generator$cwc_factory$create$0(::cwc::intrusive_ptr<component> * cwc_ret) const noexcept = 0;
			virtual ::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$generator$cwc_factory$create$1(const ::cwc::int32 * dummy, ::cwc::intrusive_ptr<component> * cwc_ret) const noexcept =0;
		public:
			auto create() const -> ::cwc::intrusive_ptr<component> {
				::cwc::intrusive_ptr<component> cwc_ret;
				::cwc::internal::call(*this, &cwc_factory::cwc$sample$fibonacci$generator$cwc_factory$create$0, &cwc_ret);
				return cwc_ret;
			}

			auto create(const ::int32_t & dummy) const -> ::cwc::intrusive_ptr<component> {
				::cwc::intrusive_ptr<component> cwc_ret;
				::cwc::internal::call(*this, &cwc_factory::cwc$sample$fibonacci$generator$cwc_factory$create$1, &dummy, &cwc_ret);
				return cwc_ret;
			}

			template<typename CWCImplementation, typename CWCTypeList>
			class cwc_implementation : public ::cwc::internal::default_implementation_chaining<CWCImplementation, CWCTypeList> {
				::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$generator$cwc_factory$create$0(::cwc::intrusive_ptr<component> * cwc_ret) const noexcept final {
					return ::cwc::internal::call_and_return_error([&] { *cwc_ret = static_cast<const CWCImplementation &>(*this).create(); });
				}
				::cwc::internal::error_code CWC_CALL cwc$sample$fibonacci$generator$cwc_factory$create$1(const ::cwc::int32 * dummy, ::cwc::intrusive_ptr<component> * cwc_ret) const noexcept final {
					return ::cwc::internal::call_and_return_error([&] { *cwc_ret = static_cast<const CWCImplementation &>(*this).create(*dummy); });
				}
			};
			static auto cwc_uuid() -> ::cwc::uuid { return {0x12, 0xEC, 0x4A, 0x37, 0x93, 0xBB, 0x54, 0x62, 0x81, 0x3E, 0xFA, 0xF0, 0x48, 0xD3, 0x64, 0x59}; }
		};
	};
}
}
}