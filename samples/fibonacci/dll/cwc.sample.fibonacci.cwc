
//          Copyright Michael Florian Hava 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include "cwc.sample.fibonacci.h"
#include <cstring>
using namespace cwc::sample::fibonacci;

namespace {
	static_assert(std::is_base_of<::cwc::sample::fibonacci::generator::cwc_component, cwc::sample::fibonacci::generator$>::value, "Implementation 'cwc::sample::fibonacci::generator$' does not fulfill the requirements of component '::cwc::sample::fibonacci::generator'");

	::cwc::internal::context_interface * cwc_context;
	std::atomic<unsigned long long> cwc_instance_counter{0};
}

auto ::cwc::internal::this_context() -> context_interface & { return *cwc_context; }
::cwc::internal::instance_counter::instance_counter() { ++cwc_instance_counter; }
::cwc::internal::instance_counter::~instance_counter() { --cwc_instance_counter; }

extern "C" CWC_EXPORT::cwc::boolean CWC_CALL cwc_unloadable() { return !cwc_instance_counter; }

extern "C" CWC_EXPORT void CWC_CALL cwc_init(::cwc::internal::context_interface * context) {
	assert(!cwc_context);
	cwc_context = context;
}

extern "C" CWC_EXPORT ::cwc::internal::error_code CWC_CALL cwc_factory(::cwc::ascii_string fqn, cwc::component::cwc_interface ** result) {
	assert(cwc_context);
	assert(result);
	return ::cwc::internal::call_and_return_error([&] {
		switch(std::strlen(fqn)) {
			case 33: {
				if(!std::strcmp(fqn, cwc::sample::fibonacci::generator$::cwc_fqn())) return *result = new typename cwc::sample::fibonacci::generator$::cwc_component_factory;
			} break;
		}
		throw std::logic_error{"unsupported component"};
	});
}

extern "C" CWC_EXPORT ::cwc::ascii_string CWC_CALL cwc_reflect() {
	return
		"//! @brief CWC Sample \"Fibonacci Generator\"\n"
		"//! @author Michael Florian Hava\n"
		"bundle cwc::sample::fibonacci {\n"
		"	interface sequence {\n"
		"		auto operator()(::cwc::uint8 no) -> ::cwc::uint64;\n"
		"	};\n"
		"\n"
		"	component generator : sequence {};\n"
		"\n"
		"	export generator;\n"
		"}\n"
	;
}