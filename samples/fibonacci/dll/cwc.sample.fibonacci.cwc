
//          Copyright Michael Florian Hava 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include "cwc.sample.fibonacci.h"
#include <cstring>
using namespace cwc::sample::fibonacci;

namespace {
	static_assert(std::is_base_of<::cwc::sample::fibonacci::generator, cwc::sample::fibonacci::generator$>::value, "Implementation 'cwc::sample::fibonacci::generator$' does not fulfill the requirements of component '::cwc::sample::fibonacci::generator'");

	::cwc::intrusive_ptr<::cwc::context> cwc_context;
}

auto ::cwc::this_context() -> ::cwc::intrusive_ptr<context> { return cwc_context; }

extern "C" CWC_EXPORT::cwc::boolean CWC_CALL cwc_unloadable() { return ::cwc::internal::instance_counter::get() == 0; }

extern "C" CWC_EXPORT void CWC_CALL cwc_init(::cwc::intrusive_ptr<::cwc::context> context) {
	assert(!cwc_context);
	cwc_context = context;
}

extern "C" CWC_EXPORT ::cwc::internal::error_code CWC_CALL cwc_factory(const ::cwc::string_view * fqn, cwc::intrusive_ptr<cwc::component> * result) {
	assert(cwc_context);
	assert(result);
	return ::cwc::internal::call_and_return_error([&] {
		switch(fqn->size()) {
			case 34: {
				if(*fqn == cwc::sample::fibonacci::generator$::cwc_fqn()) return *result = cwc::make_intrusive<typename cwc::sample::fibonacci::generator$::cwc_component_factory>();
			} break;
		}
		throw std::logic_error{"unsupported component"};
	});
}

extern "C" CWC_EXPORT void CWC_CALL cwc_reflect(::cwc::string_view * definition) {
	*definition =
		"//! @brief CWC Sample \"Fibonacci Generator\"\n"
		"//! @author Michael Florian Hava\n"
		"bundle cwc::sample::fibonacci {\n"
		"	interface sequence {\n"
		"		auto calculate(::cwc::uint8 no) -> ::cwc::uint64;\n"
		"		void calculate(array_ref<::cwc::uint8> nos, array_ref<mutable ::cwc::uint64> results);\n"
		"	};\n"
		"\n"
		"	component generator : sequence {};\n"
		"\n"
		"	export generator;\n"
		"}\n"
	;
}