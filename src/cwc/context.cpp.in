
//          Copyright Michael Florian Hava 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include <cwc/cwc.hpp>
#include <regex>
#include <fstream>
#include <sstream>
#include <unordered_map>

#ifdef _WIN32
	#define WIN32_LEAN_AND_MEAN
	#define NOSERVICE
	#define NOMCX
	#define NOIME
	#ifndef NOMINMAX
		#define NOMINMAX
	#endif
	#include <Windows.h>
#else
	#include <dlfcn.h>
	#define HMODULE void *
	#define LoadLibrary(file) dlopen(file, RTLD_NOW)
	#define GetProcAddress(dll, function) dlsym(dll, function)
#endif

namespace {
	thread_local cwc::ascii last_message[@CWC_MAX_EXCEPTION_MESSAGE_LENGTH@]{0};

	class context_impl final : public cwc::interface_implementation<cwc::context, context_impl> {
		using factory_export_type = cwc::internal::error_code(CWC_CALL *)(const cwc::string_view *, cwc::intrusive_ptr<cwc::component> *);

		using factory_map = std::unordered_map<std::string, cwc::intrusive_ptr<cwc::component>>;
		using key_value_map = std::unordered_map<std::string, std::string>;
		using config_map = std::unordered_map<std::string, key_value_map>;
		using dll_map = std::unordered_map<HMODULE, factory_export_type>;

		factory_map component_factories;
		std::unordered_map<std::string, factory_map> plugin_factories;
		const config_map configuration;

		auto load_dll(dll_map & map, const std::string & file) -> HMODULE {
			const auto handle = LoadLibrary(file.c_str());
			if(handle && !map.count(handle)) { 
				if(const auto init = reinterpret_cast<void (CWC_CALL *)(cwc::intrusive_ptr<context>)>(GetProcAddress(handle, "cwc_init"))) {
					if(const auto factory = reinterpret_cast<factory_export_type>(GetProcAddress(handle, "cwc_factory"))) {
						init(intrusive_from_this<context>());
						map[handle] = factory;
					} else throw std::logic_error{"could not find entry point 'cwc_factory' in bundle \"" + file + '"'};
				} else throw std::logic_error{"could not find entry point 'cwc_init' in bundle \"" + file + '"'};
			}
			return handle;
		}

		auto create_factory(factory_export_type factory, const std::string & file, const std::string & fqn) -> cwc::intrusive_ptr<cwc::component> {
			cwc::intrusive_ptr<cwc::component> ptr;
			const cwc::string_view tmp{fqn.c_str()};
			if(factory(&tmp, &ptr) != cwc::internal::error_code::no_error) throw std::logic_error{"could not retrieve factory for component \"" + fqn + "\" from bundle \"" + file + '"'};
			if(!ptr) throw std::logic_error{"did not receive valid factory for component \"" + fqn + "\" from bundle \"" + file + '"'};
			return ptr;
		}

		auto parse_ini(std::istream & is) -> config_map {
			config_map result;
			if(is) {
				const std::regex comment_or_whitespace{R"(\s*(?:[;#].*)?)"},
				                 section{R"(\s*\[([^\s;#]+)\]\s*(?:[;#].*)?)"},
				                 key_value_pair{R"(\s*([^\s;#]+)\s*=\s*([^\s;#]+)\s*(?:[;#].*)?)"};
				std::string line, current_section;
				while(std::getline(is, line)) {
					std::smatch matched;
					if(std::regex_match(line, matched, comment_or_whitespace)) {} //nothing to do here
					else if(std::regex_match(line, matched, key_value_pair)) result[current_section][std::move(matched[1])] = std::move(matched[2]);
					else if(std::regex_match(line, matched, section)) current_section = std::move(matched[1]);
					else throw std::logic_error{"invalid configuration file"};
				}
			}
			return result;
		}

		void load_component(dll_map & map, const std::string & fqn, const std::string & file) {
			if(const auto library = load_dll(map, file)) component_factories.emplace(fqn, create_factory(map.at(library), file, fqn));
			else throw std::logic_error{"could not load bundle \"" + file + '"'};
		}

		void load_plugins(dll_map & map, const std::string & fqn, const key_value_map & mapping) {
			for(const auto & m : mapping)
				if(const auto library = load_dll(map, m.second))
					plugin_factories[fqn].emplace(m.first, create_factory(map.at(library), m.second, fqn));
		}

		class config_section_enumerator : public cwc::interface_implementation<cwc::config_section_enumerator, config_section_enumerator> {
			key_value_map::const_iterator it, last;
		public:
			config_section_enumerator(const key_value_map & config) : it{std::begin(config)}, last{std::end(config)} {}

			auto end() const -> bool { return it == last; }

			void next() {
				if(end()) throw std::runtime_error{"already at end"};
				++it;
			}

			auto get() const -> cwc::config_entry {
				if(end()) throw std::runtime_error{"at end"};
				return {it->first.c_str(), it->second.c_str()};
			}
		};

		class config_sections_enumerator : public cwc::interface_implementation<cwc::config_sections_enumerator, config_sections_enumerator> {
			config_map::const_iterator it, last;
		public:
			config_sections_enumerator(const config_map & config) : it{std::begin(config)}, last{std::end(config)} {}

			auto end() const -> bool { return it == last; }

			void next() {
				if(end()) throw std::runtime_error{"already at end"};
				++it;
			}

			auto get() const -> cwc::config_section {
				if(end()) throw std::runtime_error{"at end"};
				return {it->first.c_str(), cwc::make_intrusive<config_section_enumerator>(it->second)};
			}
		};

	public:
		context_impl(std::istream & is) : configuration{parse_ini(is)} {
			key_value_map components;
			config_map plugins;
			const auto it = configuration.find("cwc.mapping");
			if(it != std::end(configuration)) {
				for(const auto & mapping : it->second) {
					if(mapping.second.front() != '[') components[mapping.first] = mapping.second;
					else {//key maps to section
						if(mapping.second.back() != ']') throw std::invalid_argument{"malformed configuration"};
						const auto & it = configuration.find(mapping.second.substr(1, mapping.second.size() - 2));
						if(it != std::end(configuration))
							for(const auto & entry: it->second)
								plugins[mapping.first].insert(entry);
					}
				}
			}

			dll_map map;//ensure that cwc_init is only called once
			for(const auto & c : components) load_component(map, c.first, c.second);
			for(const auto & p : plugins) load_plugins(map, p.first, p.second);
		}

		auto version() const noexcept -> cwc::string_view { return "@CWC_VERSION@"; }

		auto factory(const cwc::string_view & fqn, const cwc::optional<const cwc::string_view> & id) const -> cwc::intrusive_ptr<cwc::component> { return id ? plugin_factories.at(fqn.c_str()).at(id->c_str()) : component_factories.at(fqn.c_str()); }

		void error(cwc::string_view msg) const noexcept {
			last_message[0] = '\0';
			std::strncat(last_message, msg.c_str(), sizeof(last_message) - 1);
		}

		auto error() const noexcept -> cwc::string_view { return last_message; }

		auto config() const noexcept -> cwc::intrusive_ptr<cwc::config_sections_enumerator> { return cwc::make_intrusive<config_sections_enumerator>(configuration); }
	};

	std::atomic<bool> initialized{false};
	cwc::intrusive_ptr<cwc::context> instance;
}

namespace cwc {
	void init(init_mode mode, const char * str) {
		auto expected = false;
		if(!initialized.compare_exchange_strong(expected, true)) throw std::logic_error{"context already initialized"};
		try {
			switch(mode) {
				case cwc::init_mode::file: {
					std::ifstream is{str};
					if(!is) throw std::invalid_argument{"could not open file \"" + std::string{str} +"\" for context initialization"};
					instance = cwc::make_intrusive<context_impl>(is);
				} break;
				case cwc::init_mode::string: {
					std::istringstream is{str};
					instance = cwc::make_intrusive<context_impl>(is);
				} break;
				default: throw std::invalid_argument{"unknown context initialization mode"};
			}
		} catch(...) {
			initialized = false;
			throw;
		}
	}

	auto this_context() -> intrusive_ptr<context> {
		if(!initialized) throw std::logic_error{"context is not initialized"};
		return instance;
	}
}